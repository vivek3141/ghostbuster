In today's fast developing word of information, exchanging of data through computer networks is one of the most important topics. As cable structures are inconvenient and cause much trouble, more and more people have started using wireless connections. This modern solution is very comfortable and much easier to install in domestic, industrial, or business environment. These effective networks have one big advantage; you can connect to them from any place where you can catch the signal. But if you can do this, why somebody else cannot? And what if this person has bad intentions, what if this person should not access your network, what if you have some data you would not like to show to anybody else, if the data is confidential? This is the point where the biggest advantage of wireless networks; which is accessibility; becomes its biggest disadvantage; which is insecurity. The most efficient way to solve this problem is cryptography.
The idea of creating and managing digital identities; which appeared in 1990's due to development and delivery of e-commerce initiatives, and rapid commercial development of Internet; was key to find the ways to make them secure. One of them is a concept of public key infrastructure (PKI).
The idea is easy to understand, and can be compared with using passport. Travelling from abroad requires a passport (private key), and documented paper transactions must be made. That, however, needs to accept the document to authenticate the identity of the bearer or signer because it was attested by a trusted third party. To obtain a passport one must provide several forms of identification (public key) to satisfy passport agency requirement. While certifying the signature on the document, notary must see identification.
Within the context of a public key infrastructure (PKI), this same level of trust is needed. The digital certificates created by the certification authority permit trusted electronic relationships inside and outside the network. At the heart of PKI authentication is the concept of public key cryptography (PKC).
DEFINITION:
Public-key is commonly used to identify a cryptographic method that uses an asymmetric-key pair: a public-key and a private-key. Public-key encryption uses that key pair both for encryption and decryption. The public-key is made public and is distributed widely and freely so that everybody can use it to encrypt a message. The private-key is never distributed and must be kept secret so that only an authorised person can decode the message.
As the definition says in public key cryptography (PKC), each user is issued a key pair:
The public key can be accessed by anyone.
The private key is known only to the user and is never revealed or transmitted.
The keys are mathematically related in such a way that it is virtually impossible to guess one key from the other. We achieve this by using one-way mathematic functions. What one key of the pair encrypts, only the other one can decrypt. It is essential that while public key can be widely distributed, private key must be strictly protected.
There are two main reasons for private key protection:
Authenticity: When B receives message from A, B can be certain it came from A because it can be decrypted only by using A's public key, and that means it was encrypted using A private key. B can verify identity of the sender as only A has access to A's private key.
Confidentiality: A can send a secret message to B using B's public key (widely available) because only B holds B's private key to decrypt it.
Characteristic of public key cryptography is used to implement encryption and digital signature. PKC-based digital signatures are the most secure ones.
Digital signature is a mechanism by which a message is authenticated. It works like a signature on a paper document.
Supposing that A wants to digitally sign a message to B, A uses a one-way hash function of the document and then encrypts the hash using A's private-key, the encrypted hash is appended to the original document. Then A sends the message along with A's public-key. Only this public-key can decrypt that message. B strips off the encrypted hash and uses the A's public key to decrypt it. B also encrypts the hash from the received message, than compares it to the hash message he obtained. If values are equal, Digital Signature Verification is produced, what means that there is no doubt that it is A's private key that encrypted this message.
A sender signs a message with his private key in a way that guarantees not only that the message came from this sender, but also that it has not been modified. Even the slightest change in the document will negate the signature, as the crypto functions bind mathematically with a hash of the document. And if the message needs to be kept private, then additional encryption is added.
Public-key technology is widely used in many branches these days. Its effectiveness and reliability in both encryption and digital signature made it a useful tool in wireless networks. Algorithms used in PKC, such as RSA, made illegal decoding of a message even more complicated.
The concept of digital signature appeared few years before reasonable realization of it was available. The first practical method which fulfilled developers' expectations about digital signature was the RSA signature scheme, which main innovation was introduction of RSA algorithm. The RSA algorithm published in April 1977 was named after Ronald Rivest, Adi Shamir and Leonard Adelman who discovered and patented it. Since then, the algorithm has been used in many Internet-based applications. RSA type of encryption is employed in web browsing programs like Netscape Navigator and Microsoft Explorer, where it use used in implementations of the Secure Sockets Layer (SSL) protocol. The algorithm is also widely used in our every day's life, which we are not even aware of. Who thinks about RSA when one uses debit or credit card? But as a meter of fact RSA is the algorithm which makes these transactions possible, and secure. The companies like Mastercard and VISA employs RSA in the Secure Electronic Transactions (SET) protocol. The algorithm is used in public key cryptography which was described in previous question. But how does it work?
This cryptosystem is based on assumption: "It is not so difficult to find two large prime numbers, but it is very difficult to factor a large composite into its prime factorization form. "
This is how RSA algorithm employs one way functions. Such function is simple to do in one direction but is nearly impossible (or very hard) to inverse. According to RSA to decode a message one must find all prime factors of given number and use following mathematical algorithm to find a result:
According to RSA formula:
This operation is very hard to reverse even if we now C, e and n. That is why we change our exponent into d:
We know that:
,where p and q are prime numbers
The encryption and decryption exponents, (d) and (e), are related to each other in the following way:
So simply to find decryption key d, one must know p and q used to calculate n. And when that is done further operations are comparably easy.
Our task was to decrypt the message which was encoded with following 617 digit N number:
The encrypted message C is:
At the beginning the task seemed easy. But simple program written in Maple showed that number N is composed from more than two prime factors:
I was quite surprised, because I thought that N is composed of two prime numbers. But after consultations I knew that is not true. When N has more factors, previous formulas are slightly changed:
This could simplify my calculations. But still the number that is left after dividing N by prime factors was 607 digits:
This number is not prime so I kept searching. I gave up with my Maple program when after a week time of constant calculating my computer reached a value of 10000079. And I believe that this search was useless and would not give any results. Searching for factors with usage of this method is not effective and it would probably take few millions years for the fastest computer to solve it. The next idea which I though about was extracting square roots from the divided number, and searching for the factors around them. The value that I got was 2.697392774 * 10 33 and I did not manage to find any factors around this root. This could be more effective if I were sure that this number has only two factors left, but it could as well have more of them.
I also tried to search using some random values but without any effect. This is the Maple program which I wrote. It was very helpful but still my computer was too slow to find any result: